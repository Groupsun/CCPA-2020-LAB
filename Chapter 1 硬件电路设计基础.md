本章简单阐述硬件电路设计的基础理论知识。

# 逻辑代数

**逻辑变量**是逻辑代数中参与逻辑运算的变量，一般用字母A、B、C……表示。逻辑变量只能取两种值：0或1。在硬件电路设计当中，分为正负逻辑的规定。一般采用正逻辑规定：高电平为逻辑1，低电平为逻辑0。负逻辑规定则相反。逻辑运算有三种基本的运算，分别为与、或、非，也可以称为合取、析取、否定，也可以直接记作AND、OR、NOT。

## 逻辑运算

下表列出的是逻辑运算的记法与运算规则，加粗的是基本运算。其他的逻辑运算符都可以通过基本的逻辑运算组合得到。

| 逻辑运算 |       记法        |                        规则                        |
| :------: | :---------------: | :------------------------------------------------: |
|  **与**  |  A $\bigwedge$ B  |   当且仅当A、B都为1时，结果为1；其他情况结果为0    |
|  **或**  |   A $\bigvee$ B   |   当且仅当A、B都为0时，结果为0；其他情况结果为1    |
|  **非**  |        !A         |                 结果与A的取值相反                  |
|   异或   |  A $\bigoplus$ B  |     当A、B取值相反时，结果为1；其他情况结果为0     |
|   同或   |   A $\equiv$ B    |       结果与异或相反（即对异或运算取反得到）       |
| 实质蕴涵 | A $\rightarrow$ B | 逻辑函数表达为：A $\rightarrow$ B = !A $\bigvee$ B |

## 逻辑代数运算律

|                            逻辑或                            |                            逻辑与                            |  运算律  |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :------: |
|       A$\bigvee$(B$\bigvee$C)=(A$\bigvee$B)$\bigvee$C        |   A$\bigwedge$(B$\bigwedge$C)=(A$\bigwedge$B)$\bigwedge$C    |  结合律  |
|                   A$\bigvee$B=B$\bigvee$A                    |                 A$\bigwedge$B=B$\bigwedge$A                  |  交换律  |
|                 A$\bigvee$(A$\bigwedge$B)=A                  |                 A$\bigwedge$(A$\bigvee$B)=A                  |  吸收律  |
| A$\bigvee$(B$\bigwedge$C)=(A$\bigvee$B)$\bigwedge$(A$\bigvee$C) | A$\bigwedge$(B$\bigvee$C)=(A$\bigwedge$B)$\bigvee$(A$\bigwedge$C) |  分配律  |
|                       A$\bigvee$(!A)=1                       |                      A$\bigwedge$(!A)=0                      |  互补律  |
|                        A$\bigvee$A=A                         |                       A$\bigwedge$A=A                        |  幂等律  |
|                        A$\bigvee$0=A                         |                       A$\bigwedge$1=A                        |  有界律  |
|                        A$\bigvee$1=1                         |                       A$\bigwedge$0=0                        |  有界律  |
|                             !0=1                             |                             !1=0                             | 0与1互补 |
|              !(A$\bigvee$B)=(!A)$\bigwedge$(!B)              |              !(A$\bigwedge$B)=(!A)$\bigvee$(!B)              |  对偶律  |
|                           !(!A)=A                            |                                                              |  对合律  |

## 逻辑代数的基本规则

### 代入规则

任何一个含有变量X的等式，如果将所有出现X的位置都替换成一个逻辑函数F，此等式仍然成立。

### 对偶规则

设F是一个逻辑函数式，如果将F中的所有`*`变成`+`，`+`变成`*`，0变成1，1变成0，而变量保持不变。那么就得到了一个逻辑函数式F'，F'称为F的对偶式。如果两个逻辑函数F和G相等，那么它们的对偶式F'和G'也相等。

### 反演规则

设F是一个逻辑函数式，如果把F中的所有`*`变成`+`，`+`变成`*`，0变成1，1变成0，原变量变成反变量，反变量变成原变量。那么就得到一个逻辑函数式(!F)。

## 逻辑函数的标准形式

逻辑变量的**逻辑与运算**叫做**与项**，与项的逻辑或运算构成了逻辑函数的**与或式**，也称为**积之和式**（SP form）。

逻辑变量的**逻辑和运算**叫做**和项**，和项的逻辑与运算构成了逻辑函数的**或与式**，也称为**和之积式**（PS form）。

对于n个变量的逻辑函数而言，如果它的与项包含全部n个变量，那么这个与项就称为该逻辑函数的**最小项**。如果它的或项包含全部n个变量，那么这个或项就称为该逻辑函数的**最大项**。

## 逻辑函数的化简

通过运用逻辑代数的基本规则和运算律对逻辑函数进行变换，可以得到逻辑表达式的最简形式（最简与或式/最简或与式）。逻辑函数的化简最常使用的方法是**卡诺图**。而卡诺图就是真值表的另一种表示形式。

### 真值表

真值表用于计算逻辑表达式在每种逻辑变量取值的组合上的值，也就是说，真值表的行数与逻辑表达式的变量数目相关。逻辑表达式中有n个变量时，真值表的行数为2^n行。例如，一个半加器的真值表如下：

|  A   |  B   | Cout |  S   |
| :--: | :--: | :--: | :--: |
|  0   |  0   |  0   |  0   |
|  0   |  1   |  0   |  1   |
|  1   |  0   |  0   |  1   |
|  1   |  1   |  1   |  0   |

从真值表中可以得到输出Cout和S的逻辑表达式：
$$
Cout=A*B
$$

$$
S=A \bigoplus B
$$

### 卡诺图

卡诺图是真值表的变形，它将有n个变量的逻辑函数的2^n个最小项组织在给定的长方形表格当中。需要注意的是，表格需要遵循最小项之间逻辑相邻性以及几何相邻的统一。简单来说，就是保证每个最小项格表示的最小项与四个（如果有）相邻的最小项格表示的最小项有且只有一个变量互补。例如，逻辑函数：
$$
Z_{(A,B,C)}=\Sigma_{m}(3,5,6,7)
$$
的卡诺图为：

| A/BC  |  00  |  01  |  11  |  10  |
| :---: | :--: | :--: | :--: | :--: |
| **0** |      |      |  1   |      |
| **1** |      |  1   |  1   |  1   |

使用卡诺图来化简逻辑函数，是根据一定的原则“画圈”来合并相邻的最小项。原则如下：

- 从大圈开始画起，尽量画大圈，但每个圈内只能含有2^n个相邻项。圈需要注意对边相邻性和四角相邻性。
- 圈的个数尽量少。
- 卡诺图中所有取值为1的方格均要被圈过。
- 新画的圈内至少要有一个没有被圈过的方格。

画圈后，写出每个圈的最简与项，得到的就是最简的逻辑表达式。如上面的卡诺图得到的逻辑表达式为：
$$
f=A*C+B*C+A*B
$$

# 硬件电路设计概述

在Verilog以及VHDL等硬件描述语言（HDL）出现之前，硬件电路的设计人员主要依靠的是电路版图进行设计（74系列）。而在HDL出现后，直到现在，数字集成电路的设计可以分为以下基本步骤：系统定义、寄存器传输级设计、物理设计。而根据逻辑的抽象级别，设计又分为系统行为级、寄存器传输级、逻辑门级。在整个过程当中，设计人员需要使用数个甚至更多数量的工具、语言来设计、验证数字集成电路。而对于我们的实验以及课程来说，我们主要着眼于寄存器传输级的电路设计以及验证，也就是RTL级的电路设计。

## 寄存器传输级设计

寄存器传输级（Register-Transfer Level, RTL）实际上就是一种对电路的抽象模型，这种模型实际上就是根据数字信号在硬件寄存器、存储器、组合逻辑装置和总线等逻辑单元之间的流动，以及其逻辑代数运作的方式来确定的。在Verilog以及VHDL等的HDL语言中，被创建为对实际电路的高层次描述。

数字电路由两个主要的元素构成：寄存器和组合逻辑电路。寄存器通常由D触发器组成，可以按照时序脉冲来进行同步的时序操作，且能够保存逻辑状态信息。而组合逻辑电路则由逻辑门组成。使用HDL来设计数字集成电路，设计人员通常不需要在晶体管级别进行设计，而是在更高的抽象级别进行工程设计。设计人员只需要声明寄存器（和计算机编程语言声明变量类似），然后使用运算符以及条件语句等来表述组合逻辑的功能即可。上述的这种级别的设计就是RTL设计。

```verilog
module PC(
  input         clock,
  input         reset,
  input  [31:0] io_pc_in,
  output [31:0] io_pc_out
);
  reg [31:0] pc;
  assign io_pc_out = pc;
  always @(posedge clock) begin
    if (reset) begin
      pc <= 32'h0;
    end else begin
      pc <= io_pc_in;
    end
  end
endmodule
```

上面的Verilog代码描述的是一个极其简单的电路结构。实际上，电路当中只定义了一个寄存器`pc`，而`pc`将在每个时钟周期的上升沿（如果`reset`不为1）写入输入口`io_pc_in`的值，而输出口`io_pc_out`则输出`pc`的值。可以发现，在RTL级别的电路设计当中，设计人员不需要考虑寄存器的内部结构（门电路），而只需要关注信号在寄存器之间是如何流动的。如在上述例子当中，信号从输入口输入，写入到寄存器当中，然后经由输出口输出。同时，RTL级别的设计当中时序的信息是显式的，也就是说设计人员必须定义时序信息。

在RTL级的电路设计当中，可以分为几种电路。如果寄存器的输出端和输入端存在环路，那么这样的电路可以称为“状态机”。如果寄存器之间有连接但是没有环路，则这样的电路称为“流水线”结构。

RTL设计的描述通常会通过EDA工具转换成逻辑门电路连接的网表描述，然后再经过布线等的步骤，可以得到物理的电路。同时，这一过程还会通过使用各种模拟仿真工具来验证RTL级的描述的功能是否正确。

## 高层次设计工具入门













