本章主要阐述数字电路设计当中组合逻辑电路的设计（下）。

# 数据选择器

数据选择器是另一种经典的组合逻辑电路元件，更多的称为多路复用器（Multiplexer）。它的作用是从多个输入信号中选择其中一个信号输出的器件。数据选择器的输出输入可以分为三个部分：

- **控制信号Sel**：n位的控制信号，用于决定选择哪个信号输出；
- **输入信号In**：一般有2^n个输入信号；
- **输出信号Out**：一个输出信号端口。

最简单的数据选择器就是2-1选择器，它从两个端口A、B中选择其中一个端口输出：

![2-1数据选择器](/Users/sunnychen/Documents/CCPA2020-LAB/photos/Multiplexer_2-to-1.svg)

在这种情况下，2-1选择器的逻辑表达式如下：
$$
Z=(A \cdot \overline{S})+(B \cdot S)
$$
因此，在具体的电路实现中，实现上述的2-1选择器需要2个与门、1个或门以及1个非门。使用PyHCL来实现上述的选择器，实际上和上述半加器和全加器的方法一致，直接将逻辑表达式照搬即可，具体的实现留作读者自行练习。

如果考虑更为大型的选择器，如4-1选择器，它的逻辑表达式如下：
$$
Z=(A \cdot \overline{S_0} \cdot \overline{S_1})+(B \cdot \overline{S_0} \cdot {S_1})+(C \cdot S_0 \cdot \overline{S_1})+(D \cdot S_0 \cdot S_1)
$$
实际上，可以将上述选择器分为两个部分：1个2-4译码器以及4个三态门实现：

![4-1选择器](/Users/sunnychen/Documents/CCPA2020-LAB/photos/Mux_from_3_state_buffers.png)

## Mux、LookUpTable模块

数据选择器在数字电路中的使用非常的广泛，如果多次重复实现使用这些数据选择器，会造成不规范性。因此，PyHCL内置有数据选择器模块。`Mux`是PyHCL中内置的最简单的选择器模块，其功能相当于2-1选择器：

```python
# Mux(<选择信号>, <真输出>, <假输出>)
io.z <<= Mux(io.sel, io.b, io.a)
```

上述的`Mux`模块的含义是，当选择信号`io.sel`为真时，输出`io.b`的值。当选择信号为假时，输出`io.a`的值。其中，选择信号必须是布尔类型的电路实体。

更大规模的选择器，可以通过级联2-1选择器来实现，比如，使用3个`Mux`模块来实现一个4-1选择器：

```python
sel_result1 = Mux(io.sel[0], io.b, io.a)	# 运算符[]意为选择信号中的某一位，如此处选择sel的第0位
sel_result2 = Mux(io.sel[0], io.d, io.c)
io.z <<= Mux(io.sel[1], sel_result2, sel_result1)
```

仿真的结果如下，为了显示结果，这里人为将输入的四个端口分别预置了输入的值0～3，分别对应选择信号的值：

![4-1选择器仿真波形](/Users/sunnychen/Documents/CCPA2020-LAB/photos/four2onemux.png)

可以注意到的是，实际上，输入以及输出端口的位宽是任意的，只要都相等即可。

在某些情况下，选择信号取不同的值可能会有不同的含义，如ALU的选择信号，可能对应不同的算术逻辑运算。这时候就需要使用`LookUpTable`模块。`LookUpTable`模块是`Mux`模块的进阶版本，其形式类似于查找表，但它在PyHCL内核的实现仍然是基于`Mux`的：

```python
# 使用LookUpTable实现的4-1选择器
io.z <<= LookUpTable(io.sel, {
  U(0): io.a,
  U(1): io.b,
  U(2): io.c,
  U(3): io.d,
  ...: U(0)
})
```

`LookUpTable`接受两个参数，第一个参数是选择信号，它可以是任意基本类型，但是它必须和第二个参数中的map当中的键值类型相同。第二个参数是一个python的map数据结构，可以在其中给出当选择信号取不同的值时，所输出的信号。比如，当选择信号的值为1时，`LookUpTable`输出`io.b`。`LookUpTable`可以很灵活的进行使用，但是其效率可能会稍劣于直接使用`Mux`模块进行级联，但其可读性要强很多。FIRRTL编译器会进行一定的优化，所以在觉得使用`LookUpTable`更方便的时候，可以大胆的使用它。

# 译码器

译码器在组合逻辑电路中的使用也非常的广泛，其作用是将一个二进制数字转化为特定的对象。例如，一个典型的3-8译码器，将3位的二进制数值转化为对应数值的第n个输出置高。举例来说，当输入为011时，数值为3，则第4个输出口置高（第1个输出口表示数值0），其真值表可以表示为：

|  s2  |  s1  |  s0  |  m0  |  m1  |  m2  |  m3  |  m4  |  m5  |  m6  |  m7  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  0   |  0   |  1   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |
|  0   |  0   |  1   |  0   |  1   |  0   |  0   |  0   |  0   |  0   |  0   |
|  0   |  1   |  0   |  0   |  0   |  1   |  0   |  0   |  0   |  0   |  0   |
|  0   |  1   |  1   |  0   |  0   |  0   |  1   |  0   |  0   |  0   |  0   |
|  1   |  0   |  0   |  0   |  0   |  0   |  0   |  1   |  0   |  0   |  0   |
|  1   |  0   |  1   |  0   |  0   |  0   |  0   |  0   |  1   |  0   |  0   |
|  1   |  1   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  1   |  0   |
|  1   |  1   |  1   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  1   |

在真实的74系列译码器中，会有使能等的接口，在这里忽略。在这个译码器中，使用PyHCL实现第一时间所想到的是使用`LookUpTable`实现，这是一种方法：

```python
io.m <<= LookUpTable(io.s, {
  U(0): U(0x80),
  U(1): U(0x40),
  U(2): U(0x20),
  U(3): U(0x10),
  U(4): U(0x08),
  U(5): U(0x04),
  U(6): U(0x02),
  U(7): U(0x01),
  ...: U(0)
})
```

实际上，你还可以使用右移运算符：

```python
io.m <<= U(0x80) >> io.s
```

3-8译码器的仿真结果如下：

![3-8译码器仿真波形](/Users/sunnychen/Documents/CCPA2020-LAB/photos/decoder.png)

# 实验内容与练习

## 2-1选择器与4-1选择器

使用PyHCL来实现上述的2-1选择器与4-1选择器，并自行仿真验证其正确性。

## 数据分配器

数据分配器是与数据选择器相反的功能器件，它将一个输入分配到2^n个输出当中，分配信号为n。如一个1-2的数据分配器如下：

![1-2数据分配器](/Users/sunnychen/Documents/CCPA2020-LAB/photos/Demultiplexer.png)

请使用PyHCL实现一个1-4数据分配器，并自行仿真验证其正确性。

## 编码器

编码器是与译码器相反的功能器件，它将输入编码为二进制数值输出。一个3位优先级的编码器真值表如下：

|  s7  |  s6  |  s5  |  s4  |  s3  |  s2  |  s1  |  s0  |  m2  |  m1  |  m0  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  1   |  x   |  x   |  x   |  x   |  x   |  x   |  x   |  1   |  1   |  1   |
|  0   |  1   |  x   |  x   |  x   |  x   |  x   |  x   |  1   |  1   |  0   |
|  0   |  0   |  1   |  x   |  x   |  x   |  x   |  x   |  1   |  0   |  1   |
|  0   |  0   |  0   |  1   |  x   |  x   |  x   |  x   |  1   |  0   |  0   |
|  0   |  0   |  0   |  0   |  1   |  x   |  x   |  x   |  0   |  1   |  1   |
|  0   |  0   |  0   |  0   |  0   |  1   |  x   |  x   |  0   |  1   |  0   |
|  0   |  0   |  0   |  0   |  0   |  0   |  1   |  x   |  0   |  0   |  1   |
|  0   |  0   |  0   |  0   |  0   |  0   |  0   |  1   |  0   |  0   |  0   |

优先级编码器规定，输入端位数越高优先级越高。如当输入的第6位为1，第7位为0时，无论第0～5位值为多少，其输出的编码值都是110（即数值6）。请使用PyHCL来实现上述的3位优先级编码器，并自行仿真验证其正确性。

## 简易ALU

算术逻辑单元（ALU）是CPU当中的核心运算部件。假设一个简易的ALU，它只支持4种运算，分别是加、减、乘以及除。ALU有以下的IO端口：

- 两个数据输入端口`src_a`以及`src_b`，类型为32位无符号整数。
- 一个2位的控制信号`aluop`，用于选择所要进行的算术运算。
- 一个结果输出端口`result`，类型为32位无符号整数。

规定，控制信号为0时，进行加法运算。控制信号为1时，进行减法运算。控制信号为2时，进行乘法运算。控制信号为3时，进行除法运算。规定a作为被操作的运算数（左操作数），b为右操作数。请用PyHCL实现上述的简易ALU，并自行仿真验证其正确性。

# 思考

## Map与LookUpTable

上述的LookUpTable的使用，可以发现都是手工构造Map来实现的。然而，很多时候查找表具有一定的规律性，可以使用特定的方式来进行构造，也就是说，可以通过一个python函数的方式来构造一个Map。不妨可以尝试使用一个函数来构造一个选择器或者译码器的Map结构。

## `=`与`<<=`

在4-1级联实现的代码中，是一个区分`=`与`<<=`实现的典型例子。在PyHCL内核中，综合电路的关键是扫描所有的`<<=`连接符来构造一棵语法树。这里提出的一个问题是，如果我把`sel_result1`以及`sel_result2`对应的运算符换为`<<=`，代码需要作出怎样的修改？

## 仲裁

仲裁是一种重要的组合逻辑结构，它将输入（一般来自于一个FIFO的数据结构）进行仲裁，决定哪个输出口能够获得该数据，如下图：

![仲裁](/Users/sunnychen/Documents/CCPA2020-LAB/photos/arbiter.png)

思考如何实现上述的仲裁结构，假设三个端口都有如下的信号：

- 数据端口，类型为32位无符号整数；
- ready端口，布尔类型；
- valid端口，布尔类型。

`valid`端口用于告知外部设备数据是否有效，它需要考虑`ready`端口是否为高，以及优先级性。这里规定PE0的优先级比PE1更高。下面给出Arbiter的输入输出端口声明，思考如何实现其逻辑：

```python
class Arbiter(Module):
  io = IO(
    // FIFO
    fifo_valid=Input(Bool)
    fifo_ready=Output(Bool)
    fifo_data=Input(U.w(32))
    
    // PE0
    pe0_valid=Output(Bool)
    pe0_ready=Input(Bool)
    pe0_data=Output(U.w(32))
    
    // PE1
    pe1_valid=Output(Bool)
    pe1_ready=Input(Bool)
    pe1_data=Output(U.w(32))
  )
  
  # ???
```
