本章主要阐述数字电路中设计中时序逻辑电路的设计。

# 时序逻辑电路理论基础

组合逻辑电路的稳态输出只与当前的输入有关。而时序逻辑电路的稳态输出不仅取决于当前的输入，还与前一刻输入形成的状态有关。也就是说，时序逻辑电路具有储存元件来存储信息，而组合逻辑电路则没有。时序逻辑电路可以构筑为有限状态机或者是某些形式的电脑内存。绝大部分现实中的数字集成电路，都是时序逻辑电路以及组合逻辑电路的组合。

描述时序逻辑电路不能仅由输入的状态来决定，因此对时序逻辑电路功能表述需要使用多个方程组：

**输出方程组**。描述输出与当前输入以及电路逻辑状态的关系，其中输入规定为$y_j$ ，输入规定为$x_i$，电路逻辑状态为$q_k$：
$$
y_j=f_j(x_1, x_2, ..., x_i, q_1, q_2, ..., q_k)
$$
**驱动/激励方程组**。描述当前输入以及电路逻辑状态产生的驱动信号：
$$
z_j=g_j(x_1, x_2, ..., x_i, q_1, q_2, ..., q_k)
$$
**状态/次态方程组**。描述下一时刻的电路逻辑状态与当前驱动信号以及电路逻辑状态的关系：
$$
q_{k_{n+1}}=h_k=(z_1, z_2, ..., z_k, q_{1_{n}}, q_{2_{n}}, ..., q_{k_{n}})
$$

## 同步时序逻辑电路

如今几乎所有的时序逻辑电路都是同步时序逻辑电路。在同步时序逻辑电路当中，所有存储元件都在时钟脉冲的统一控制下。对于所有存储元件来说（触发器、寄存器、内存单元），其存储的内部状态都只会在时钟的**边沿**（可以是上升沿，也可以是下降沿）改变。因此，同步时钟电路最大的优点是实现简单，在两个寄存器之间的组合逻辑电路的运算，必须在时钟的两个边沿间隔内完成（通常称为一个时钟周期）。

# 寄存器

寄存器是时序逻辑电路中的基本部件，学习时序逻辑电路，就要从学习寄存器的性质开始。寄存器一般由D触发器构成，寄存器的特点是，在每个时钟边沿（一般是上升沿，在后文当中，默认所有的边沿都指上升沿）会将当前储存的逻辑状态改变为输入的逻辑状态。也就是说，在每个时钟的上升沿，输入端的数据会写入到寄存器当中。

在PyHCL当中，定义寄存器有两种方式，分别是`Reg()`以及`RegInit()`。两者的区别是后者在`reset`信号置高的时候会将寄存器的值设为初始值。定义寄存器的例子如下：

```python
counter = Reg(U.w(32))	# 定义一个存储32位无符号整数的寄存器counter
value = RegInit(S.w(16)(0))	# 定义一个存储16位有符号整数的寄存器value，且初始值为0
```

不妨使用一个最简单的寄存器的模块例子，以及其生成的Verilog代码以及仿真波形来观察寄存器的行为：

```python
class Register(Module):
    io = IO(
        _in=Input(U.w(32)),
        out=Output(U.w(32))
    )

    reg = Reg(U.w(32))
    reg <<= io._in
    io.out <<= reg
```

所生成的Verilog代码（忽略了一些对实际逻辑不会产生影响的代码）：

```verilog
module Register(
  input         clock,
  input         reset,
  input  [31:0] io__in,
  output [31:0] io_out
);
  reg [31:0] reg_;
  assign io_out = reg_;
  always @(posedge clock) begin
    reg_ <= io__in;
  end
endmodule
```

可以发现，寄存器`reg_`在每个时钟上升沿，都会写入输入口`io__in`的值，而输出口`io_out`则会输出寄存器当前的值。下面再来看看仿真的结果：

![寄存器波形仿真结果](./photos/register1.png)

在仿真设定中，输入口的数据在时钟的下降沿变化，并持续一个时钟周期。可以发现，寄存器的状态只会在时钟上升沿时发生变化，写入当前输入端口的值。

从上面PyHCL以及Verilog的代码当中，我们还可以发现一个区别，那就是在PyHCL代码中，**具体的时序信息会被隐藏起来**。因此，在使用PyHCL进行电路建模的时候，需要对寄存器的操作有一个时序的模型在脑海当中。也就是说，**所有写入到寄存器相关的操作，都是依赖于时钟信息的**。下面看另一个例子：

```python
class Register(Module):
    io = IO(
        out=Output(U.w(32))
    )

    counter = RegInit(U.w(32)(0))
    counter <<= counter + U(1)
    io.out <<= counter
```

这个例子当中，寄存器`counter`会不断的自增。上面说过，所有写入寄存器的操作都和时钟相关。因此，这个自增的操作反映到实际的电路时序模型当中，就是在每个时钟周期的上升沿自增：

![寄存器的自增](./photos/register2.png)

在上面的例子当中，我们使用了`RegInit()`来构造寄存器。在使用了这种寄存器的电路当中，需要注意在仿真开始前必须要把`reset`信号置高，否则寄存器可能会发生初始化问题。置高`reset`信号（一般1～2个时钟周期即可）后寄存器就能设置为代码中规定的初始值0。

## 控制逻辑















