本章主要阐述数字电路中设计中时序逻辑电路的设计。

# 时序逻辑电路理论基础

组合逻辑电路的稳态输出只与当前的输入有关。而时序逻辑电路的稳态输出不仅取决于当前的输入，还与前一刻输入形成的状态有关。也就是说，时序逻辑电路具有储存元件来存储信息，而组合逻辑电路则没有。时序逻辑电路可以构筑为有限状态机或者是某些形式的电脑内存。绝大部分现实中的数字集成电路，都是时序逻辑电路以及组合逻辑电路的组合。

描述时序逻辑电路不能仅由输入的状态来决定，因此对时序逻辑电路功能表述需要使用多个方程组：

**输出方程组**。描述输出与当前输入以及电路逻辑状态的关系，其中输入规定为$y_j$ ，输入规定为$x_i$，电路逻辑状态为$q_k$：
$$
y_j=f_j(x_1, x_2, ..., x_i, q_1, q_2, ..., q_k)
$$
**驱动/激励方程组**。描述当前输入以及电路逻辑状态产生的驱动信号：
$$
z_j=g_j(x_1, x_2, ..., x_i, q_1, q_2, ..., q_k)
$$
**状态/次态方程组**。描述下一时刻的电路逻辑状态与当前驱动信号以及电路逻辑状态的关系：
$$
q_{k_{n+1}}=h_k=(z_1, z_2, ..., z_k, q_{1_{n}}, q_{2_{n}}, ..., q_{k_{n}})
$$

## 同步时序逻辑电路

如今几乎所有的时序逻辑电路都是同步时序逻辑电路。在同步时序逻辑电路当中，所有存储元件都在时钟脉冲的统一控制下。对于所有存储元件来说（触发器、寄存器、内存单元），其存储的内部状态都只会在时钟的**边沿**（可以是上升沿，也可以是下降沿）改变。因此，同步时钟电路最大的优点是实现简单，在两个寄存器之间的组合逻辑电路的运算，必须在时钟的两个边沿间隔内完成（通常称为一个时钟周期）。

# 寄存器

寄存器是时序逻辑电路中的基本部件，学习时序逻辑电路，就要从学习寄存器的性质开始。寄存器一般由D触发器构成，寄存器的特点是，在每个时钟边沿（一般是上升沿，在后文当中，默认所有的边沿都指上升沿）会将当前储存的逻辑状态改变为输入的逻辑状态。也就是说，在每个时钟的上升沿，输入端的数据会写入到寄存器当中。

在PyHCL当中，定义寄存器有两种方式，分别是`Reg()`以及`RegInit()`。两者的区别是后者在`reset`信号置高的时候会将寄存器的值设为初始值。定义寄存器的例子如下：

```python
counter = Reg(U.w(32))	# 定义一个存储32位无符号整数的寄存器counter
value = RegInit(S.w(16)(0))	# 定义一个存储16位有符号整数的寄存器value，且初始值为0
```

不妨使用一个最简单的寄存器的模块例子，以及其生成的Verilog代码以及仿真波形来观察寄存器的行为：

```python
class Register(Module):
    io = IO(
        _in=Input(U.w(32)),
        out=Output(U.w(32))
    )

    reg = Reg(U.w(32))
    reg <<= io._in
    io.out <<= reg
```

所生成的Verilog代码（忽略了一些对实际逻辑不会产生影响的代码）：

```verilog
module Register(
  input         clock,
  input         reset,
  input  [31:0] io__in,
  output [31:0] io_out
);
  reg [31:0] reg_;
  assign io_out = reg_;
  always @(posedge clock) begin
    reg_ <= io__in;
  end
endmodule
```

可以发现，寄存器`reg_`在每个时钟上升沿，都会写入输入口`io__in`的值，而输出口`io_out`则会输出寄存器当前的值。下面再来看看仿真的结果：

![寄存器波形仿真结果](./photos/register1.png)

在仿真设定中，输入口的数据在时钟的下降沿变化，并持续一个时钟周期。可以发现，寄存器的状态只会在时钟上升沿时发生变化，写入当前输入端口的值。

从上面PyHCL以及Verilog的代码当中，我们还可以发现一个区别，那就是在PyHCL代码中，**具体的时序信息会被隐藏起来**。因此，在使用PyHCL进行电路建模的时候，需要对寄存器的操作有一个时序的模型在脑海当中。也就是说，**所有写入到寄存器相关的操作，都是依赖于时钟信息的**。下面看另一个例子：

```python
class Register(Module):
    io = IO(
        out=Output(U.w(32))
    )

    counter = RegInit(U.w(32)(0))
    counter <<= counter + U(1)
    io.out <<= counter
```

这个例子当中，寄存器`counter`会不断的自增。上面说过，所有写入寄存器的操作都和时钟相关。因此，这个自增的操作反映到实际的电路时序模型当中，就是在每个时钟周期的上升沿自增：

![寄存器的自增](./photos/register2.png)

在上面的例子当中，我们使用了`RegInit()`来构造寄存器。在使用了这种寄存器的电路当中，需要注意在仿真开始前必须要把`reset`信号置高，否则寄存器可能会发生初始化问题。置高`reset`信号（一般1～2个时钟周期即可）后寄存器就能设置为代码中规定的初始值0。

## 控制逻辑

PyHCL提供了一组控制逻辑原语来帮助使用者方便的书写类似高级编程语言当中的条件判断语句，其实现的原理实际上就是`Mux`原语嵌套。在时序逻辑电路当中，对控制逻辑的使用会非常多。PyHCL中实现的控制逻辑原语有三个，分别为：`when()`，`elsewhen()`以及`otherwise()`。分别对应`if`，`elif`以及`else`逻辑关系。在PyHCL中实现为对象的`__enter__()`以及`__exit__()`方法。因此，在使用上述三个逻辑控制原语的时候需要使用`with`关键字：

```python
with when(counter >= U(10)):
  io.flag <<= Bool(True)
  io.eflag <<= Bool(False)
  counter <<= U(0)
with elsewhen((counter >= 5) & (counter < 10)):
  io.flag <<= Bool(False)
  io.eflag <<= Bool(True)
  counter <<= counter + U(1)
with otherwise():
  counter <<= counter + U(1)
```

需要注意的是，在PyHCL当中，如果需要将逻辑判断组合来写，需要在**所有**内嵌的逻辑运算中加上括号，且与运算的优先级无关。如上面例程中的`(counter >= 5) & (counter < 10)`。下面举一个实例来说明控制逻辑的运用以及进一步探讨寄存器的性质：

```python
class Register(Module):
    io = IO(
        flag_out=Output(Bool),
        wflag_out=Output(Bool)
    )

    counter = RegInit(U.w(32)(0))
    flag = RegInit(Bool(False))
    io.flag_out <<= flag
    with when(counter > U(9)):
        flag <<= Bool(True)
        counter <<= U(0)
        io.wflag_out <<= Bool(True)
    with otherwise():
        counter <<= counter + U(1)
        io.wflag_out <<= Bool(False)
        flag <<= Bool(False)
```

上述模块逻辑实现的意义是，寄存器`counter`作为一个计数器，当计数超过10时上溢置零，并将寄存器`flag`置为真。模块有两个输出，它们赋值的方式有所不同：`flag_out`输出的是寄存器`flag`的值，而`wflag_out`输出的则是直接的逻辑字面值。这个例子的仿真结果为：

![仿真结果](./photos/register3.png)

可以发现，寄存器的写入会延后一个时钟周期。实际上，结合寄存器的性质可以很容易解释这一点，当寄存器的数值到达最大值之后，此时逻辑规定写入寄存器的值变为高，但是写入寄存器必须发生在时钟的上升沿，可以理解为比较寄存器值和最大值发生在20~22us之间的时钟周期的组合逻辑当中，因此写入到寄存器必须发生在后一个周期。但是`wflag_out`的输出是纯组合逻辑电路，它可以即时反应逻辑结果，因此它在`counter`为10的周期立即置高。

这个例子反应的看似是一个很简单的问题，但是在实际的电路开发当中，必须时刻注意寄存器这种写的滞后性，否则开发的电路时序可能会产生诸多问题。



















