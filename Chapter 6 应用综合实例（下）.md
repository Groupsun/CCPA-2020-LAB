本章继续介绍相关的应用实例。

# FIR滤波器

有限脉冲响应（FIR）滤波器在DSP领域的使用非常广泛，并且其非常适合于使用FIFO的方式来实现。对滤波器的输入脉冲信号得到的输出信号为该滤波器的脉冲响应。由名字可以知道，FIR滤波器的脉冲响应是有限的。滤波器的输出可以通过卷积的方法来计算出滤波器的输出信号。例如，N阶的FIR滤波器的系数h于输入信号x的卷积可以由差分方程表示：
$$
y[i]=\sum_{j=0}^{N-1}h[j] \cdot x[i-j]
$$
也就是说，实现一个N阶的FIR滤波器需要N个乘法以及N-1个加法实现。

## Vector

在讨论FIR滤波器的实现之前，首先介绍PyHCL支持的一种组合类型（或者叫复杂类型）：Vector。Vector用于定义数组类类型，声明一个Vector类型的方式为：

```python
Vec(<size>, <basic-type>)
```

- `size`是指该数组类型的大小；
- `basic-type`是指该数组元素的类型，必须为基本类型，如无符号/有符号整数以及布尔类型

例如，实现一个寄存器数组，大小为4，寄存器保存的数据类型是32位无符号整数，则可以以如下的方式实现：

```python
ar = Reg(Vec(4, U.w(32)))
```

但是`Vec`有一个缺陷，就是它无法指定初始值，这使得在使用寄存器的时候带来一些尴尬的问题。因此，这里建议`Vec`类型尽量**只在输入输出端口**使用。而声明一个寄存器数组可以使用另外一种方式，也就是利用函数式编程的方式：

```python
ar = [RegInit(U.w(32)(0)) for _ in range(4)]
```

这种声明方式下，`ar`是一个python的`List`对象，但是其存储的对象是PyHCL的寄存器。使用这种方式声明的寄存器数组，其运算方式与使用`Vec`声明的方式无异，而且它更为灵活。

> **抽象以及代码的层级性**
>
> 当使用`Vec`类型的时候，通过观察生成的FIRRTL代码，可以发现`ar`在FIRRTL代码中同样是一个寄存器数组：
>
> ```
> reg ar : UInt<32>[4], clock
> ```
>
> 但是在经过FIRRTL编译器后，所生成的Verilog代码当中，实际上没有使用寄存器数组，而是拆开来声明：
>
> ```
> reg [31:0] ar_0;
> reg [31:0] ar_1;
> reg [31:0] ar_2;
> reg [31:0] ar_3;
> ```
>
> 在这种情况下，在不同代码层级上的抽象程度不同会影响代码的结构。并且当涉及到FIRRTL编译器行为时，PyHCL显得无力。因此当使用PyHCL时，有一定的底层结构了解是必要的。
>
> 在后一种实现时，也就是使用Python的`List`对象来实现一个寄存器数组，其生成的FIRRTL代码即会将寄存器拆开来声明。在这种情况下，我们更关心的是最后生成的硬件在资源占用、延时等方面会不会出现差异，当然，这是更深层次的研究和思考，在这里只作为题外话提出。

现在考虑实现一个8位的FIR滤波器模块，这个模块是参数化的，参数是数据的位宽`width`。首先，可以首先实现一个系数也是由外界输入的FIR滤波器，其特点是：

- 输入数据沿着移位寄存器不断滑动（当然，你也可以使用多个寄存器来实现这个FIFO结构，而且这种方式更容易用上函数式编程的方法）；
- 两个输入端口，一个是输入信号端口`x`，另一个是`Vec`类型的输入端口，作为系数输入端口；
- 一个输出端口，也就是输出信号端口。

FIR滤波器的结构图如下，下图中的系数记为b：

![FIR滤波器结构](./photos/fir_filter.svg)

这里提供一个参数化实现的模版：

```python
def firfilter(width: int):
  class FIRFilter(Module):
    io = IO(
      i=Input(U.w(width)),
      const=Input(Vec(8, U.w(width))),
      out=Output(U.w(width))
    )
    
    # 实现逻辑
```

实际上，系数大多数情况下都是确定的，它不需要耗费多一个输入端口来实现，况且这还是一个向量输入端口，会占用大量的系统资源。考虑一个参数化的FIR滤波器，它的参数是位宽`width`以及系数，系数是一个`List`结构的参数：

```python
def firfilter(width: int, consts: List):
  class FIRFilter(Module):
    io = IO(
      i=Input(U.w(width)),
      out=Output(U.w(width))
    )
    
    # 实现逻辑
```

请读者分别实现上述两个FIR滤波器，并自行仿真验证测试。

# 简易神经元

考虑实现一个神经网络当中全连接层的神经元结构。一个全连接层中的神经元所要完成的计算工作包括：对n个输入以及对应的n个权重进行MAC运算（乘加累积运算），并将结果作为激活函数的输入，最后得到该神经元的输出结果。一个简单的全连接神经元的结构如下图：

![神经元结构](./photos/neuron.png)

为了简化实现，规定数值输入以及权重的输入均为二进制整数。且忽略激活函数中的threshold因子，下面给出神经元的模块模版：

```python
def neuron(n: int, width: int):
  class Neuron(Module):
    io = IO(
      x=Input(Vec(n, U.w(width))),
      weight=Input(Vec(n, U.w(width))),
      out=Output(U.w(width))
    )
    
    # MAC实现
    # 激活函数实现
```

激活函数有多种实现方式，这里要求实现ReLU的激活函数，它的定义如下：
$$
relu(x)=
\begin{cases}
0, & x \leq 0 \\
x, & x > 0
\end{cases}
$$
在讨论如何实现MAC之前，首先来讨论python在函数化编程中会使用到的高阶函数。

## 高阶函数

在python当中，函数名也是变量，它实际上就是指向函数的变量。那么，可以在函数的参数当中接收指向函数的变量。这种函数就叫做高阶函数。

### map/reduce

在高阶函数中最经典的应用就是map/reduce。Python内建了`map()`和`reduce()`函数。首先看`map()`函数，它接受两个参数，一个是函数，另一个是`Iterable`，通常是`List`。比如，有一个函数f(x)=x^2，要把这个函数作用在一个`List`上，就可以使用`map()`来实现：

```python
def f(x):
  return x*x

r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
```

`r`输出的结果为：`[1, 4, 9, 16, 25, 36, 49, 64, 81]`。我们再来看`reduce()`。`reduce()`把一个函数作用在一个序列`[x1, x2, ..., ]`上，所以其效果就是：

```
reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
```

例如要求一个数组的和，可以这样实现：

```python
def add(x, y):
  return x + y

sum = reduce(add, [1, 3, 5, 7, 9])
```

当然python内置了`sum()`方法，这里只是作为演示来讨论。可以发现，上面每次都要定义函数还是过于麻烦，这时候可以利用匿名函数`lambda`来实现：

```python
sum = reduce(lambda x, y:x+y, [1, 3, 5, 7, 9])
```

如何将高阶函数与PyHCL结合起来使用？请读者考虑使用`map()`以及`reduce()`实现上述神经元的MAC模块。

> HINT：zip()方法可以打包两个数组模块，如：
>
> ```python
> >>>a = [1,2,3]
> >>> b = [4,5,6]
> >>> zipped = zip(a,b)     # 打包为元组的列表
> [(1, 4), (2, 5), (3, 6)]
> ```
>
> `Vec`的实现了迭代器的行为，它是iterable的。因此你同样可以使用`zip()`来合并两个`Vec`的输入端口：
>
> ```python
> zip(io.x, io.weight)
> # 得到的结果就是：[(io.x[0], io.weight[0]), (io.x[1], io.weight[1]), ...]
> ```

# 实验内容和练习

这一章节当中的实验内容包括上述需要读者自行实现并验证的所有内容，并包括一些简单的不需要详细讲解的实例练习。

## 堆栈的硬件实现

上一章节当中提到了FIFO队列的硬件实现，这一章节当中，请读者尝试实现一个硬件的FILO堆栈结构，并自行仿真验证。

## Matrix

上面让读者尝试实现了MAC模块，实际上，这个模块可以重用到矩阵相乘的实现当中。假设A是MxN矩阵，B是NxP矩阵，那么他们的乘积AB会是一个MxP矩阵，其乘积矩阵的元素由下面的式子给出：
$$
(AB)_{ij}=\sum_{r=1}^n a_{ir}b_{rj}=a_{i1}b_{1j}+a_{i2}b_{2j}+...+a_{in}b_{nj}
$$
考虑实现一个两个4x4方阵之间相乘的模块，并利用MAC的计算原理，计算矩阵的乘积。